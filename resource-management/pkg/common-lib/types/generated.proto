/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = 'proto2';

package k8s.io.api.global_resource_service.resource_management.pkg.common_lib.types;

// Package-wide variables from generator "generated".
option go_package = "types";

// LogicalNode is the abstraction of the node definition in the resource clusters
// LogicalNode is a minimum set of information the scheduler needs to place the workload to a node in the region-less platform
//
// Initial set of fields as shown below.
//
// TODO: add the annotation for serialization
message LogicalNode {
  // Node UUID from each resource partition cluster
  optional string id = 1;

  // ResourceVersion is the RV from each resource partition cluster
  optional string resource_version = 2;

  // GeoInfo defines the node location info such as region, DC, RP cluster etc. for application placement
  optional NodeGeoInfo geo_info = 3;

  // Taints defines scheduling or other control action for a node
  optional NodeTaints taints = 4;

  // SpecialHardwareTypes defines if the node has special hardware such as GPU or FPGA etc
  optional NodeSpecialHardWareTypeInfo special_hardware_types = 5;

  // AllocatableReesource defines the resources on the node that can be used by schedulers
  optional NodeResource allocatable_resource = 6;

  // Conditions is a short version of the node condition array from Arktos, each bits in the byte defines one node condition
  optional int32 conditions = 7;

  // Reserved defines if the node is reserved at the resource partition cluster level
  // TBD Node reservation model for post 630
  optional bool reserved = 8;

  // MachineType defines the type of category of the node, such as # of CPUs of the node, where the category can be
  // defined as highend, lowend, medium as an example
  // TBD for post 630
  optional string machine_type = 9;

  // LastUpdatedTime defines the time when node status was updated in resource partition
  optional Time last_updated_time = 10;
}

// NodeEvent is a event of nodes
message NodeEvent {
  optional string id = 1;

  optional LogicalNode node = 2;
}

message NodeGeoInfo {
  // Region and RsourcePartition are required
  optional int64 region = 1;

  optional int64 rp = 2;

  // Optional fields for fine-tuned resource management and application placements
  optional string dc = 3;

  optional string az = 4;

  optional string fd = 5;
}

// struct definition from Arktos node_info.go
message NodeResource {
  optional int64 milli_cpu = 1;

  optional int64 memory = 2;

  optional int64 ephemeral_storage = 3;

  // We store allowedPodNumber (which is Node.Status.Allocatable.Pods().Value())
  // explicitly as int, to avoid conversions and improve performance.
  optional int32 allowed_pod_number = 4;

  // ScalarResources such as GPU or FPGA etc.
  map<string, int64> scalar_resources = 5;
}

// TODO: consider refine for GPU types, such as NVIDIA and AMD etc.
message NodeSpecialHardWareTypeInfo {
  optional bool hasgpu = 1;

  optional bool hasfpga = 2;
}

message NodeTaints {
  // Do not allow new pods to schedule onto the node unless they tolerate the taint,
  // Enforced by the scheduler.
  optional bool no_schedule = 1;

  // Evict any already-running pods that do not tolerate the taint
  optional bool no_execute = 2;
}

// RRM: Resource Region Manager
// TODO: the RvMap is not needed when sending data from the region manager to the aggregator for the pull model, as the
//       aggegrator assumes all nodes are sent from the CRV speficied in the pull request. in fact, this is ingored in
//       aggregator code.
message ResponseFromRRM {
  repeated RpNodeEvents region_node_events = 1;

  // bytes representation of TransitResourceVersionMap
  // protobuf map key types: https://developers.google.com/protocol-buffers/docs/proto3#maps
  optional bytes rvmap = 2;

  optional uint64 length = 3;
}

// RpNodeEvents is a struct for node events from each RP
message RpNodeEvents {
  repeated NodeEvent node_events = 1;
}

// Time is a wrapper around time.Time which supports correct
// marshaling to YAML and JSON.  Wrappers are provided for many
// of the factory methods that the time package offers.
//
// +protobuf.options.marshal=false
// +protobuf.as=Timestamp
// +protobuf.options.(gogoproto.goproto_stringer)=false
message Time {
}

